// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: query.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addEmployeeToTeam = `-- name: AddEmployeeToTeam :exec
INSERT INTO
  team_employees (employee_id, team_id)
VALUES
  ($1, $2)
`

type AddEmployeeToTeamParams struct {
	EmployeeID int32 `db:"employee_id" json:"employee_id"`
	TeamID     int32 `db:"team_id" json:"team_id"`
}

func (q *Queries) AddEmployeeToTeam(ctx context.Context, arg AddEmployeeToTeamParams) error {
	_, err := q.db.Exec(ctx, addEmployeeToTeam, arg.EmployeeID, arg.TeamID)
	return err
}

const createEmployee = `-- name: CreateEmployee :one
INSERT INTO
  employees (
    name,
    last_name,
    birth_date,
    enter_date,
    gender
  )
VALUES
  ($1, $2, $3, $4, $5) RETURNING id, name, last_name, birth_date, enter_date, creation_date, gender, picture_hash
`

type CreateEmployeeParams struct {
	Name      string      `db:"name" json:"name"`
	LastName  string      `db:"last_name" json:"last_name"`
	BirthDate pgtype.Date `db:"birth_date" json:"birth_date"`
	EnterDate pgtype.Date `db:"enter_date" json:"enter_date"`
	Gender    pgtype.Text `db:"gender" json:"gender"`
}

func (q *Queries) CreateEmployee(ctx context.Context, arg CreateEmployeeParams) (*Employee, error) {
	row := q.db.QueryRow(ctx, createEmployee,
		arg.Name,
		arg.LastName,
		arg.BirthDate,
		arg.EnterDate,
		arg.Gender,
	)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.LastName,
		&i.BirthDate,
		&i.EnterDate,
		&i.CreationDate,
		&i.Gender,
		&i.PictureHash,
	)
	return &i, err
}

const createTeam = `-- name: CreateTeam :one
INSERT INTO
  teams (name, topics)
VALUES
  ($1, $2) RETURNING id, name, topics
`

type CreateTeamParams struct {
	Name   string   `db:"name" json:"name"`
	Topics []string `db:"topics" json:"topics"`
}

func (q *Queries) CreateTeam(ctx context.Context, arg CreateTeamParams) (*Team, error) {
	row := q.db.QueryRow(ctx, createTeam, arg.Name, arg.Topics)
	var i Team
	err := row.Scan(&i.ID, &i.Name, &i.Topics)
	return &i, err
}

const getCities = `-- name: GetCities :many
SELECT
  country_code,
  name,
  state_name
FROM
  cities
LIMIT $1
`

type GetCitiesRow struct {
	CountryCode string `db:"country_code" json:"country_code"`
	Name        string `db:"name" json:"name"`
	StateName   string `db:"state_name" json:"state_name"`
}

func (q *Queries) GetCities(ctx context.Context, limit int32) ([]*GetCitiesRow, error) {
	rows, err := q.db.Query(ctx, getCities, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetCitiesRow{}
	for rows.Next() {
		var i GetCitiesRow
		if err := rows.Scan(&i.CountryCode, &i.Name, &i.StateName); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCitiesByCountry = `-- name: GetCitiesByCountry :many
SELECT
  country_code,
  name,
  state_name
FROM
  cities
WHERE
  (country_code = $1)
LIMIT $2
`

type GetCitiesByCountryParams struct {
	CountryCode string `db:"country_code" json:"country_code"`
	Limit       int32  `db:"limit" json:"limit"`
}

type GetCitiesByCountryRow struct {
	CountryCode string `db:"country_code" json:"country_code"`
	Name        string `db:"name" json:"name"`
	StateName   string `db:"state_name" json:"state_name"`
}

func (q *Queries) GetCitiesByCountry(ctx context.Context, arg GetCitiesByCountryParams) ([]*GetCitiesByCountryRow, error) {
	rows, err := q.db.Query(ctx, getCitiesByCountry, arg.CountryCode, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetCitiesByCountryRow{}
	for rows.Next() {
		var i GetCitiesByCountryRow
		if err := rows.Scan(&i.CountryCode, &i.Name, &i.StateName); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountries = `-- name: GetCountries :many
SELECT
  code, name
FROM
  countries
`

func (q *Queries) GetCountries(ctx context.Context) ([]*Country, error) {
	rows, err := q.db.Query(ctx, getCountries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Country{}
	for rows.Next() {
		var i Country
		if err := rows.Scan(&i.Code, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeeByID = `-- name: GetEmployeeByID :one
SELECT
  id, name, last_name, birth_date, enter_date, creation_date, gender, picture_hash
FROM
  employees
WHERE
  id = $1
LIMIT
  1
`

func (q *Queries) GetEmployeeByID(ctx context.Context, id int32) (*Employee, error) {
	row := q.db.QueryRow(ctx, getEmployeeByID, id)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.LastName,
		&i.BirthDate,
		&i.EnterDate,
		&i.CreationDate,
		&i.Gender,
		&i.PictureHash,
	)
	return &i, err
}

const updateEmployeeLocation = `-- name: UpdateEmployeeLocation :exec
INSERT INTO
  employees_location (employee_id, city_id, postal_code)
VALUES
  ($1, $2, $3)
`

type UpdateEmployeeLocationParams struct {
	EmployeeID int32       `db:"employee_id" json:"employee_id"`
	CityID     pgtype.UUID `db:"city_id" json:"city_id"`
	PostalCode pgtype.Text `db:"postal_code" json:"postal_code"`
}

func (q *Queries) UpdateEmployeeLocation(ctx context.Context, arg UpdateEmployeeLocationParams) error {
	_, err := q.db.Exec(ctx, updateEmployeeLocation, arg.EmployeeID, arg.CityID, arg.PostalCode)
	return err
}
